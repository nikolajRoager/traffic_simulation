<h1 id="a-custom-container-for-storing-vehicles-on-a-road">A custom
container for storing vehicles on a road</h1>
<p>no default container really works well in this case, std::set comes
close ... but I do not trust it to always work when the sorting key
changes.</p>
<p>This container will only be used for the RoadVehicle class, but will
work for anything T, with a &lt; operator for T and double</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>This must be a fully functioning C++ container, compatible with all
algorithms in the &lt;algorithm&gt; header (it will not be a sequence
container, since the order of insertion fundamentally does not
matter)</p>
<p>The pre-requisite for this container is that vehicles are sorted
based on position. position must be between 0 and length.</p>
<p>position can change without the container knowing about it (e.g.
someone else stores a pointer to the vehicle and tell it to update), but
we require that the relative ordering of the cars never change
(overtaking requires deletion of the car on one lane, and insertion in
another), the container should optionally have a "detect sorting errors"
function</p>
<p>Vehicles can be inserted in O(log(N)) time based on position, a
version of lower bound and upper bound should exist (to get get vehicles
before or after an target position, or before or after any other
vehicle), all this should use the CURRENT position</p>
<p>Random insertion and deletion must be possible (corresponding to
overtaking) allow fast insertion and deletion of vehicles at any
location (should be O(log n) very fast insertion of vehicles at one end,
and deletion in other (this is the main mode vehicles enter and leave)
O(1)</p>
<p>Getting next and previous car should be O(1)</p>
<p>For this reason, a AVL tree + double Linked List system will be used.
The AVL tree is a perfectly ordinary AVL tree, which uses left/right
rotations, and leftright and rightleft rotations to maintain balance of
the trees.</p>
<p>The linked list is updated on insertion and deletion of elements, and
links elements in order of value.</p>
<h2 id="methods-and-members">Methods and members</h2>
<p>The tree has a custom iterator for stepping through the tree from
lowest to smallest, it implements all requirements for containers: These
work exactly the way they are required for a container (plus some extra
from SequenceContainter and Associative container):</p>
<pre><code>Lane();
Lane(const Lane&amp; other);
Lane(Lane&amp;&amp; other);
Lane&amp; operator=(const Lane&amp; other);
Lane&amp; operator=(Lane&amp;&amp; other);
~Lane();
Lane::iterator begin();
Lane::iterator end();
const Lane::const_iterator begin()const;
const Lane::const_iterator end()  const;
bool operator==(const Lane&lt;T&gt;&amp; other);
bool operator!=(const Lane&lt;T&gt;&amp; other);
void swap(Lane&lt;T&gt;&amp; other);
static void swap(Lane&lt;T&gt;&amp; a,Lane&lt;T&gt;&amp; b);
size_type size();
size_type max_size();
bool empty();</code></pre>
<p>Additionally this constructor copies from any other container in O(N
log(N)):</p>
<pre><code>template&lt;LegacyInputIterator Iter&gt;//Accepts any input iterator
    Lane(Iter start, Iter end);</code></pre>
<p>The tree provides these functions, ideally in time O(log(N)), it is
likely pretty obvious how they work, there can only be one element with
the same value (otherwise it is overwritten):</p>
<pre><code>void insert(T t);
void push_back(T t);//Same as insert, used for the std::back_inserter to work
size_type count(double t);
size_type count(T t);
iterator find(T t);
iterator find(double t);

//return end() if the element does not exist
iterator lower_bound(T t);
iterator lower_bound(double t);
iterator upper_bound(T t);
iterator upper_bound(double t);</code></pre>
<p>The linked list structure provides a function for checking if
everything is sorted:</p>
<pre><code>bool is_still_sorted() noexcept;</code></pre>
<p>It also provides functions for get the element just before, or just
before or after an iterator in time O(1), or at the start and end, these
return false if the requested element do not exist</p>
<pre><code>bool first(T&amp; out) noexcept;
bool last (T&amp; out) noexcept;

bool next(T&amp; out, const_iterator&amp;) noexcept;
bool prev(T&amp; out, const_iterator&amp;) noexcept;
bool next(const T&amp; out, const_iterator&amp;) const noexcept;
bool prev(const T&amp; out, const_iterator&amp;) const noexcept;</code></pre>
<p>By mixing these with <code>lower\_bound</code>,
<code>upper\_bound</code> and <code>find</code>, we can make these
O(log(N)) functions:</p>
<pre><code>bool next(T&amp; out, const T&amp;) noexcept;
bool prev(T&amp; out, const T&amp;) noexcept;
bool next(const T&amp; out, const T&amp;) const noexcept;
bool prev(const T&amp; out, const T&amp;) const noexcept;</code></pre>
<h2 id="laneiterator">Lane::iterator</h2>
<p>The Lane::iterator must be a <em>LegacyForwardIterator</em>, quoting
from <a
href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator"
title="Cppreference, Forward Iterator">cpprforward</a>: a
<em>LegacyForwardIterator</em> need to satisfy
<em>LegacyInputIterator</em> which in turns require
<em>LegacyIterator</em>. Below are the combined requirements for all
three requirements from <a
href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator"
title="Cppreference, Forward Iterator">cpprforward</a>, (and pages
linked from that):</p>
<p>Here <code>X</code> is the iterator type, <code>T</code> is the value
type, <code>i</code> and <code>j</code> are iterator instances,
<code>R</code> is <code>std::iterator_traits&lt;X&gt;::reference</code>,
and <code>r</code> is of type <code>R</code></p>
<p>X satisfies <em>LegacyForwardIterator</em> if all following
conditions are satisfied:</p>
<pre><code>for LegacyIterator:
    X satisfies DefaultConstructible.
    The type X satisfies CopyConstructible, and
    The type X satisfies CopyAssignable, and
    The type X satisfies Destructible, and
    lvalues of type X satisfy Swappable, and
    std::iterator_traits&lt;X&gt; has member typedefs value_type(until C++20), difference_type, reference, pointer, and iterator_category
additionally for LegacyInputIterator:
    X satisfies EqualityComparable.
for LegacyForwardIterator:
    If X is a mutable iterator, R is a reference to T.
    If X is a constant iterator, R is a reference to const T.
    Objects of the type X provide multi-pass guarantee.
    If i and j are equal, then either i and j are both dereferenceable or else neither is dereferenceable.
    If i and j are both dereferenceable, then i == j if and only if *i and *j are bound to the same object.</code></pre>
<p>In addition, the following expressions must be valid, have the
expected types and have their specified effects:</p>
<table>
<thead>
<tr class="header">
<th>Expression</th>
<th>Type</th>
<th>Effects</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*r</code></td>
<td>unspecified</td>
<td><code>r</code> is dereferenceable</td>
</tr>
<tr class="even">
<td><code>++r</code></td>
<td><code>R</code></td>
<td><code>r</code> is incrementable (the behavior of the expression
<code>++r</code> is defined)</td>
</tr>
<tr class="odd">
<td><code>i!=j</code></td>
<td>convertible to <code>bool</code></td>
<td>Same as <code>!(i==j)</code></td>
</tr>
<tr class="even">
<td><code>*i</code></td>
<td><code>R</code>, convertible to <code>T</code></td>
<td><code>i==j</code> then <code>*i==*j</code></td>
</tr>
<tr class="odd">
<td><code>i-&gt;m</code></td>
<td></td>
<td><code>(*i).m</code></td>
</tr>
<tr class="even">
<td><code>++r</code></td>
<td><code>R</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>(void)r++</code></td>
<td>Equivilent to <code>(void)++r</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>r++</code></td>
<td>convertible to <code>const X&amp;</code></td>
<td>Same as <code>X x=r; ++r; return x;</code></td>
</tr>
<tr class="odd">
<td><code>*r++</code></td>
<td>convertible to <code>R</code></td>
<td></td>
</tr>
</tbody>
</table>
